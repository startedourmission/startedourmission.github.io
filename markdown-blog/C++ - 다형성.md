---
date: 2025-06-30
tags:
  - C++
aliases:
---

# 다형성

C++에서 다형성(Polymorphism)은 객체 지향 프로그래밍의 핵심 개념 중 하나로, '여러 가지 형태를 가질 수 있는 능력'을 의미합니다. 이를 통해 같은 이름의 함수나 연산자가 상황에 따라 다르게 동작하도록 할 수 있으며, 코드의 재사용성, 유지보수성, 유연성을 향상시킵니다.

C++의 다형성은 크게 두 가지 유형으로 나뉩니다.

## 1. 컴파일 타임 다형성 (정적 다형성, Static Polymorphism)

*   컴파일 시점에 어떤 함수가 호출될지 결정됩니다.
*   **함수 오버로딩 (Function Overloading)**: 같은 이름의 함수를 사용하지만, 매개변수의 개수나 타입이 다를 때 컴파일러가 적절한 함수를 선택합니다.
*   **연산자 오버로딩 (Operator Overloading)**: 연산자에 새로운 의미를 부여하여 특정 데이터 타입에 대해 다르게 동작하도록 합니다.

## 2. 런타임 다형성 (동적 다형성, Dynamic Polymorphism)

*   프로그램 실행 시점(런타임)에 어떤 함수가 호출될지 결정됩니다.
*   주로 상속과 가상 함수(virtual function)를 통해 구현됩니다.
*   **가상 함수 (Virtual Function)**:
    *   기반 클래스(Base Class)에 `virtual` 키워드를 사용하여 선언된 멤버 함수로, 파생 클래스(Derived Class)에서 재정의(override)될 수 있습니다.
    *   기반 클래스 포인터나 참조를 통해 파생 클래스 객체의 가상 함수를 호출할 때, 실제 객체의 타입에 따라 적절한 함수가 호출되도록 합니다. 이를 동적 바인딩(Dynamic Binding) 또는 늦은 바인딩(Late Binding)이라고 합니다.
    *   가상 함수를 사용하는 클래스는 가상 소멸자(virtual destructor)를 가지는 것이 좋습니다.
*   **순수 가상 함수 (Pure Virtual Function) 및 추상 클래스 (Abstract Class)**:
    *   순수 가상 함수는 `= 0`으로 선언된 가상 함수로, 기반 클래스에서 구현을 제공하지 않고 파생 클래스에서 반드시 재정의해야 합니다.
    *   하나 이상의 순수 가상 함수를 포함하는 클래스를 추상 클래스라고 합니다.
    *   추상 클래스는 직접 객체를 생성할 수 없으며, 오직 기반 클래스로만 사용될 수 있습니다. 이는 파생 클래스가 특정 함수를 구현하도록 강제하여 공통 인터페이스를 제공하는 역할을 합니다.

### 가상 함수 테이블 (vtable)의 역할

런타임 다형성은 **가상 함수 테이블 (Virtual Function Table, vtable)**이라는 메커니즘을 통해 구현됩니다. 가상 함수를 하나라도 포함하는 클래스는 컴파일러에 의해 해당 클래스의 가상 함수들의 주소를 담고 있는 `vtable`이 생성됩니다. 그리고 이 클래스의 객체가 생성될 때, 객체 내부에 `vptr` (virtual pointer)이라는 숨겨진 포인터가 추가되어 해당 클래스의 `vtable`을 가리키게 됩니다.

기반 클래스 포인터나 참조를 통해 가상 함수를 호출하면, 컴파일러는 `vptr`을 통해 `vtable`에 접근하고, `vtable`에 저장된 실제 함수 주소를 찾아 호출합니다. 이 과정은 런타임에 이루어지므로, 객체의 실제 타입에 따라 올바른 함수가 호출될 수 있습니다.

### 다형성 사용 시 주의사항

*   **가상 소멸자 (Virtual Destructor) 사용**: 상속 계층 구조에서 기본 클래스 포인터를 통해 파생 클래스 객체를 `delete`할 경우, 기본 클래스의 소멸자가 `virtual`로 선언되어 있지 않으면 파생 클래스의 소멸자가 호출되지 않아 메모리 누수가 발생할 수 있습니다. 따라서 다형성을 사용하는 클래스 계층에서는 기본 클래스의 소멸자를 반드시 `virtual`로 선언해야 합니다.
*   **성능 오버헤드**: 가상 함수 호출은 일반 함수 호출보다 약간의 런타임 오버헤드가 발생합니다. `vtable`을 조회하는 과정이 추가되기 때문입니다. 하지만 대부분의 애플리케이션에서는 이 오버헤드가 미미하여 큰 문제가 되지 않습니다.
*   **생성자/소멸자에서 가상 함수 호출**: 생성자나 소멸자 내에서 가상 함수를 호출하면, 해당 시점에는 객체가 완전히 생성되거나 소멸되지 않은 상태이므로 다형성이 제대로 작동하지 않을 수 있습니다. 이 경우 현재 생성/소멸 중인 클래스의 버전이 호출됩니다.
*   **`override` 키워드 사용**: C++11부터 도입된 `override` 키워드를 사용하여 파생 클래스에서 가상 함수를 재정의할 때 명시적으로 표시하는 것이 좋습니다. 이는 오타나 잘못된 시그니처로 인한 오류를 컴파일러가 감지하도록 도와줍니다.
*   **`final` 키워드 사용**: C++11부터 도입된 `final` 키워드를 사용하여 더 이상 상속될 수 없는 클래스나 더 이상 재정의될 수 없는 가상 함수를 지정할 수 있습니다. 이는 설계 의도를 명확히 하고 불필요한 상속을 방지합니다.

다형성은 동일한 인터페이스를 통해 다양한 객체에 대해 다른 동작을 수행할 수 있게 하여, 유연하고 확장 가능한 코드 설계를 가능하게 합니다.

---
### C++ 기본

- [[C++ - 개요 및 C 언어와의 차이점]]
- [[C++ - 기본 문법]]
- [[C++ - 컴파일과 링크]]
- [[C++ - IDE 및 개발 환경]]

### 객체 지향 프로그래밍 (OOP)

- [[C++ - 클래스와 객체]]
- [[C++ - 생성자 및 소멸자]]
- [[C++ - 캡슐화]]
- [[C++ - 상속]]
- [[C++ - 다형성]]
- [[C++ - 추상화]]

### 메모리 관리

- [[C++ - 동적 메모리 할당]]
- [[C++ - 스마트 포인터]]

### 고급 C++ 기능

- [[C++ - 포인터]]
- [[C++ - 참조]]
- [[C++ - 템플릿]]
- [[C++ - 예외 처리]]
- [[C++ - 표준 라이브러리 (STL)]]
- [[C++ - 파일 입출력]]
- [[C++ - 현대 C++]]

### 실무 C++

- [[C++ - 빌드 시스템]]
- [[C++ - 테스트 프레임워크]]
- [[C++ - 디버깅 기법]]
- [[C++ - 성능 최적화]]
- [[C++ - 디자인 패턴]]
- [[C++ - 실무에서 사용하는 C++의 변형]]
