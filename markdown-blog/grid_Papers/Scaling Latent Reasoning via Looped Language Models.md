---
date: 2025-11-17
tags:
  - 논문
  - LLM
aliases:
image: "![[1-Scaling.png]]"
description: Chain-of-Thought는 학습 후의 조정일 뿐입니다. 사전학습 단계부터 조정해 모델 내부 잠재 공간에서 반복적으로 생각하게 만들면 더 좋지 않을까요? Ouro 모델은 이 아이디어를 7.7조 개의 토큰으로 구현합니다. 1.4B와 2.6B 모델이 12B 모델 수준의 성능을 낼 수 있음을 보였습니다. 핵심은 더 많은 지식을 저장하는 게 아니라 기존 지식을 더 잘 조합하고 조작하는 능력입니다.
---
오늘날 거의 모든 대규모 언어 모델은 두 단계로 작동합니다. 첫 번째는 대량의 텍스트로 "보편적인 언어 능력"을 학습하는 사전학습 단계이고, 두 번째는 지도학습이나 강화학습을 통해 추론과 문제 해결 능력을 갖추는 사후학습 단계입니다. 

그런데 여기 문제가 있습니다. 사후학습에서 모델이 배우는 추론 방식은 대부분 텍스트를 길게 생성해서 생각하는 **Chain-of-Thought** 형태입니다. 이 방식은 인간이 손으로 쓴 추론 과정을 따라 하도록 학습되지만, 실제로는 최종 답을 정한 후 그에 맞게 텍스트를 만드는 경향이 있습니다. 또한 텍스트 생성을 통한 추론은 사전학습 데이터의 풍부한 신호를 제대로 활용하지 못합니다.

![[1-Scaling.png]]
이 연구는 사후학습에서 추론을 배우는 대신 사전학습 단계 자체에 반복적인 계산을 내장합니다. 모델 내부의 숨겨진 표현(잠재 공간)에서 여러 번 반복해서 정보를 가공하고 정제합니다. 이들이 개발한 Ouro 모델 가족은 이 아이디어를 최대 규모로 검증했으며, 작은 모델이 훨씬 큰 모델과 경쟁할 수 있음을 보였습니다.
## 요약

루프된 언어모델(Looped Language Model, LoopLM)은 가중치를 공유하는 트랜스포머 층 블록을 반복적으로 적용하는 구조입니다. 입력이 같은 층 스택을 여러 번 통과하면서, 각 단계마다 숨겨진 상태가 점진적으로 정제됩니다. 이 과정은 외부에 노출되지 않으면서도 내부적으로 깊이 있는 계산을 수행합니다.

> R. Zhu, Z. Wang, K. Hua, et al., "Scaling Latent Reasoning via Looped Language Models," arXiv preprint arXiv:2510.25741v2, 2025.

http://ouro-llm.github.io

**핵심 구성 요소:**

- **반복 구조**: 같은 층 블록을 최대 4회 반복 실행
- **적응형 종료 게이트**: 각 단계마다 "더 계산할 필요가 있는지" 판단하는 출구 확률 학습
- **엔트로피 정규화**: 종료 분포가 특정 깊이로 붕괴되지 않도록 균등한 사전확률 유지
- **대규모 사전학습**: 7.7조 토큰으로 1.4B, 2.6B 모델 학습

**성능 수치:**

- Ouro 1.4B (4 반복 단계) → Qwen3 4B와 동등한 성능
- Ouro 2.6B (4 반복 단계) → Qwen3 8B 능가 (특히 수학/추론)
- 수학 벤치마크 MATH500: 82.4% (Qwen3 4B 59.6% 대비)

**사용 기술:** 파라미터 공유 트랜스포머 / KV 캐시 재사용 / 조건부 조기 종료 / 물리 기반 지식 능력 분석

---

## 상세 분석

### 1. 왜 다시 생각해야 하나?

**전통적 LLM의 구조적 한계:**

일반적인 LLM 학습 과정을 보면, 사전학습은 "다음 토큰 예측"이라는 단순한 목표로 진행됩니다. 이 단계에서 모델은 주로 패턴 인식과 기본적인 지식 저장에 집중합니다. 반면 추론 능력은 사후학습 단계에서 인간이 작성한 Chain-of-Thought 예제로 나중에 생깁니다. 마치 이미 완성된 건물에 나중에 엘리베이터를 달아주는 것 같습니다.

바이트 댄스가 찾은 이 방식의 문제점은 두 가지입니다. 첫째, 사전학습의 방대한 데이터 신호가 추론 능력 향상에 충분히 활용되지 않습니다. 두 번째, 텍스트로 생성된 추론 과정이 실제로 최종 답에 인과적으로 영향을 주는지 불명확합니다. 연구에 따르면 모델은 답을 먼저 정한 후 그에 맞는 설명을 생성하는 경향이 있습니다.

**제시되는 대안:**

논문의 핵심 아이디어는 추론을 "내부 계산"으로 바꾸는 것입니다. 외부에 텍스트로 표현되지 않은 채, 모델의 숨겨진 층 내에서만 반복적으로 정보를 가공합니다. 이는 인간이 말하지 않은 채로 생각하는 것과 유사합니다.

### 2. 루프된 언어 모델

**기본 아키텍처:**

일반적인 트랜스포머는 $L$개의 층을 한 번씩 거칩니다:

$$F(\cdot) = \text{lmhead} \circ M_L \circ M_{L-1} \circ \cdots \circ M_1 \circ \text{emb}(\cdot)$$

LoopLM은 같은 층 스택을 $t$번 반복합니다:

$$F^{(t)}(\cdot) = \text{lmhead} \circ \underbrace{M_L \circ \cdots \circ M_1 \circ \cdots \circ M_L \circ \cdots \circ M_1}_{t \text{ 반복}} \circ \text{emb}(\cdot)$$

핵심은 가중치 공유입니다. 층 1부터 층 L까지의 파라미터가 동일하게 유지되면서 반복됩니다. 이는 파라미터 수는 증가하지 않으면서도 계산 깊이를 늘립니다.

**각 단계의 역할:**

각 반복 단계 $t$에서 모델은 다음을 수행합니다:

1. 입력 데이터를 층 스택에 통과시킨다
2. 최종 은닉 상태를 얻는다
3. 그 상태에서 언어 모델링 손실을 계산한다
4. 다음 반복으로 진행할지 종료할지를 판단하는 게이트를 실행한다

이 구조의 이점은 단순함입니다. 복잡한 추가 메커니즘 없이, 기존 트랜스포머 블록을 반복 사용하기만 하면 됩니다.

### 3. 적응형 종료: 쿼리가 결정한다

모든 입력이 같은 수의 반복이 필요할까요? 간단한 질문은 한 두 단계로 충분할 수 있지만, 복잡한 추론 문제는 더 많은 계산이 필요할 수 있습니다.

**출구 확률 메커니즘:**

각 단계 $t$에서 모델은 출구 확률을 학습합니다:

$$\lambda_t(x) = \sigma(\text{Linear}_\phi(h^{(t)}))$$

여기서 $h^{(t)}$는 단계 $t$의 최종 은닉 상태이고, 시그모이드 함수가 0과 1 사이의 확률을 생성합니다. 이를 누적하면 생존 확률(survival probability)이 됩니다:

$$S_t(x) = \prod_{j=1}^{t} (1 - \lambda_j(x))$$

첫 번째 단계에서 종료될 확률, 두 번째에서 종료될 확률 등이 이렇게 정의되면, 추론 시간에 임계값 $q$를 기준으로 조기에 종료할 수 있습니다:

$$t_{\text{exit}}(x) = \min{ m : \text{CDF}(m | x) \geq q }$$

### 4. 학습 목표: 두 단계 접근

모델이 게이트를 학습하는 방법이 중요합니다.

**1단계: 엔트로피 정규화를 통한 탐색**

순진하게 손실만 최소화하면, 게이트가 깊은 단계로만 확률을 집중시키는 문제가 발생합니다(붕괴 현상). 이를 방지하기 위해 균등 사전확률을 가정한 KL 발산을 추가합니다:

$$L = \sum_{t=1}^{T_{\max}} p_\phi(t | x) L^{(t)} - \beta H(p_\phi(\cdot | x))$$

여기서 $H$는 엔트로피이고, $\beta$는 탐색과 착취 간 균형을 조절합니다. 균등 사전확률은 "모든 깊이가 동등하게 유용할 수 있다"는 신호를 제공합니다.

**2단계: 손실 개선 신호를 이용한 미세 조정**

사전학습이 끝난 후, 게이트만 추가로 학습시킵니다. 각 단계에서의 손실 개선을 직접 측정하고, 그에 따라 종료 결정을 조정합니다:

$$w_i^{(t)} = \sigma(k \cdot (I_i^{(t)} - \gamma))$$

여기서 $I_i^{(t)} = \max(0, L_i^{(t-1)} - L_i^{(t)})$는 $t-1$ 단계에서 $t$ 단계로 갈 때의 손실 개선입니다. 개선이 크면 계속 진행하고, 작으면 종료합니다.

### 5. 지식 저장 vs. 지식 조작: 물리 기반 실험

여기서 놀라운 발견이 나옵니다. LoopLM이 성공하는 이유가 더 많은 지식을 저장하기 때문일까요?

**합성 데이터를 통한 검증:**

연구진은 "Capo" 작업이라는 제어된 실험을 설계했습니다. 가짜 인물 기록(이름, 생년월일, 직업 등)을 생성하고, 모델이 이를 얼마나 잘 기억하는지 측정합니다. 결과는 놀라웠습니다:

- 루프된 모델과 루프되지 않은 모델 모두 파라미터당 약 2비트의 정보를 저장합니다
- 지식 용량 확장에는 루프 구조가 영향을 주지 않습니다

그렇다면 LoopLM의 성능 향상은 어디서 올까요?

**지식 조작 능력:**

"Mano" 작업(나무 구조의 모듈러 산술)과 "다중-홉 질의응답"에서 다른 결과가 나타났습니다. 루프된 모델이 더 적은 샘플로 더 빠르게 학습했습니다. 특히 파라미터 수가 같은 경우에도, 루프된 모델이 지식을 조합하고 조작하는 작업에서 우수했습니다.

이는 중요한 구분입니다. LoopLM은 "더 많이 알지만" 모를 더 효율적으로 "사용"합니다.

### 6. 실제 성능: 벤치마크 결과

**기본 모델 성과:**

Ouro 1.4B (4 반복 단계)는 많은 벤치마크에서 Qwen3 4B와 동등합니다:

- MMLU: 72.3% (Qwen3 4B 70.95%)
- BBH: 71.02% vs 70.95%
- GSM8K (수학): 78.92% vs 72.86%
- MATH500: 82.40% vs 59.60%

수학 문제에서의 우위는 특히 두드러집니다. 반복적 추론이 다단계 문제 해결에 더 효과적임을 시사합니다.

**추론 모델 (Ouro-Thinking):**

지도 미세조정과 강화학습 후:

- AIME 2024 통과율 (pass@1): 65% (Qwen3 4B 61.3%)
- OlympiadBench: 71.55% (Ouro 1.4B, Qwen3 4B 73.18%)
- SuperGPQA: 71.55% (Ouro 2.6B, Qwen3 8B 56.45%)

### 7. 깊이의 영향: 더 깊을수록 나을까?

학습 시 4 단계로 제한했지만, 추론 시 더 많은 단계(5-8)를 사용했을 때 어떻게 될까요?

**외삽(Extrapolation) 행동:**

표준 벤치마크(MMLU, ARC)에서는 4 단계에서 최고 성능을 보인 후 5-8 단계에서 성능이 저하됩니다. 하지만 흥미롭게도 안전성 평가(HEx-PHI)에서는 더 깊은 단계에서 해로운 응답이 감소했습니다. 이는 반복적 정제가 내용 품질과 안전성에 다르게 영향을 줄 수 있음을 시사합니다.

### 8. 조기 종료의 실제 효율성

**세 가지 종료 전략 비교:**

1. 고정 깊이: 항상 모든 반복 수행 (기준선)
2. 은닉 상태 차이: $||h^{(t)} - h^{(t-1)}|| < \epsilon$에서 종료
3. 학습된 게이트: 엔트로피 정규화 버전 vs 손실 개선 신호 버전

MMLU 벤치마크에서:

- 평균 2.5 반복 단계에서 전문 학습 게이트가 66% 정확도 달성
- 기본 게이트: 64%
- 고정 깊이: 더 낮은 정확도

적응형 게이트가 계산 효율성과 성능을 모두 개선합니다.

### 9. 이론적 이해: 그래프 탐색 문제

수학적으로, LoopLM이 왜 지식 조작에 강한지 설명할 수 있습니다.

**정리 (비공식):** 최대 크기가 $n$인 결합 그래프에서, LoopLM은 $O(\log_2 D)$번의 반복(D는 그래프의 직경)만으로 두 노드 사이의 경로 존재 여부를 판단할 수 있습니다.

이는 순차적 체인-오브-소트의 $O(D)$보다 지수적으로 효율적입니다. 반복적 잠재 계산이 병렬 처리에 더 적합하다는 것을 의미합니다.

### 10. 안전성과 충실성

**안전성:**

HEx-PHI 데이터셋(해로운 질문 330개)에서:

- Ouro 1.4B-Thinking: 유해율 0.009 (Qwen3 4B-Thinking과 동등)
- 재귀 단계가 증가할수록 안전성 개선

PCA 분석 결과, 더 깊은 단계에서 해로운 질문과 무해한 질문의 표현이 더 명확하게 분리됩니다.

**충실성 (신뢰성):**

Quora Question Pairs 데이터셋에서 선형 프로브를 사용한 분석:

- Qwen3 4B-Thinking: 최종 답이 이미 단계 1에서 결정됨 (ROC AUC 0.99)
- Ouro 1.4B: 단계 2-4에서 실제로 의사결정 변화 (단계 간 일치도 36-56%)

이는 LoopLM의 반복이 진정한 계산인지, 아니면 후식 합리화인지를 구분합니다. 루프된 구조에서는 각 단계가 이전 결정을 수정합니다.

---

## 결론

LoopLM은 언어 모델의 추론을 생각하는 방식을 바꿉니다. 외부적 텍스트 생성에서 내부적 반복 계산으로 이동함으로써, 같은 파라미터 수로 훨씬 더 강력한 능력을 달성할 수 있음을 보였습니다.

**세 가지 핵심 발견:**

1. **효율성**: 1.4B LoopLM이 4B 모델과 경쟁할 수 있습니다. 이는 제한된 계산 환경에서 배포되는 모델에 중요합니다.
    
2. **메커니즘**: 성능 향상의 원천은 더 큰 저장 용량이 아니라 더 나은 지식 조합입니다. 이는 앞으로의 연구 방향을 명확히 합니다.
    
3. **신뢰성**: 반복적 계산이 텍스트 생성을 통한 추론보다 더 충실하고 조작되지 않은 추론 과정을 만듭니다.
    

다만 현재 연구의 한계도 있습니다. 강화학습 시도는 성공하지 못했고(vLLM의 동적 계산 미지원), 외삽 성능도 제한적입니다. 또한 매우 긴 추론 작업에서의 효율성은 여전히 문제입니다.

그럼에도 불구하고 이 연구는 중요한 메시지를 전달합니다. **모델 크기 확대만이 능력 향상의 유일한 경로가 아니라는 것입니다.** 계산 깊이를 지능적으로 할당하는 것도 새로운 스케일링 축이 될 수 있습니다. 앞으로 더 많은 모델이 이 접근을 채택할 가능성이 높습니다.

