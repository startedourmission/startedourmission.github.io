---
date: 2025-06-30
tags:
  - C++
aliases:
---

# 현대 C++

C++는 지속적으로 발전하는 언어로, 몇 년마다 새로운 표준이 발표되어 새로운 기능과 개선 사항을 도입합니다. 다음은 C++11, C++14, C++17, C++20, C++23의 주요 특징입니다.

## C++11 (2011년 발표)
C++11은 C++ 언어에 혁신적인 변화를 가져온 주요 업데이트로, 현대 C++ 프로그래밍의 기반이 되었습니다.
*   **이동 시맨틱 (Move Semantics) 및 Rvalue 참조 (Rvalue References):** 불필요한 복사를 줄여 성능을 향상시킵니다.
*   **람다 표현식 (Lambda Expressions):** 익명 함수를 코드 내에서 직접 정의할 수 있게 하여 간결하고 유연한 코드를 작성할 수 있도록 합니다.
*   **`auto` 키워드:** 변수의 타입을 컴파일러가 자동으로 추론하게 하여 코드 작성의 편의성을 높입니다.
*   **`nullptr`:** 널 포인터를 명확하게 나타내는 키워드로, 기존의 `NULL` 매크로 사용으로 인한 타입 관련 모호성을 해결합니다.
*   **범위 기반 `for` 루프 (Range-based for loop):** 컨테이너의 요소를 쉽게 순회할 수 있도록 합니다.
*   **스마트 포인터 (Smart Pointers):** `std::unique_ptr`, `std::shared_ptr` 등을 도입하여 메모리 관리를 자동화하고 메모리 누수를 방지합니다.
*   **동시성 지원 (Concurrency Support):** `std::thread`, `std::mutex` 등 멀티스레딩을 위한 라이브러리 지원을 추가했습니다.
*   **`constexpr`:** 컴파일 타임에 평가될 수 있는 함수나 변수를 지정하여 성능을 최적화합니다.
*   **초기화 리스트 (Initializer Lists):** 중괄호를 사용하여 객체를 통일된 방식으로 초기화할 수 있도록 합니다.

## C++14 (2014년 발표)
C++14는 C++11의 확장으로, 주로 C++11의 기능을 개선하고 새로운 작은 기능들을 추가했습니다.
*   **일반화된 람다 (Generic Lambdas):** `auto`를 사용하여 람다 매개변수의 타입을 추론할 수 있게 합니다.
*   **람다 캡처 초기화 (Lambda Capture Initializers):** 람다 캡처 시 임의의 표현식으로 초기화할 수 있게 합니다.
*   **함수 반환 타입 추론 (Function Return Type Deduction):** 일반 함수에서도 `auto`를 사용하여 반환 타입을 추론할 수 있게 합니다.
*   **`decltype(auto)`:** `auto`와 `decltype`의 조합으로, 복잡한 타입 추론을 더 유연하게 만듭니다.
*   **`constexpr` 함수의 제약 완화:** `constexpr` 함수 내에서 더 많은 종류의 문(statement)을 사용할 수 있게 합니다.
*   **`std::make_unique`:** `std::unique_ptr`를 생성하는 편리한 방법을 제공합니다.

## C++17 (2017년 발표)
C++17은 언어와 라이브러리 모두에 걸쳐 다양한 개선 사항을 도입했습니다.
*   **구조적 바인딩 (Structured Bindings):** 배열, 구조체, `std::pair`, `std::tuple` 등의 요소를 여러 변수로 쉽게 분해할 수 있게 합니다.
*   **`if` 및 `switch` 문 내 초기화 (Initialization in if/switch statements):** 조건문 내에서 변수를 선언하고 초기화할 수 있게 합니다.
*   **`constexpr if`:** 컴파일 타임에 조건에 따라 코드 블록을 선택적으로 컴파일할 수 있게 합니다.
*   **중첩된 네임스페이스 (Nested Namespaces):** `namespace A::B { ... }`와 같이 중첩된 네임스페이스를 간결하게 정의할 수 있습니다.
*   **파일 시스템 라이브러리 (`std::filesystem`):** 파일 및 디렉토리 경로를 조작하고 파일 시스템 작업을 수행하는 표준 방법을 제공합니다.
*   **`std::variant`, `std::optional`, `std::any`:** 다양한 유틸리티 타입을 도입하여 타입 안전성을 높이고 유연한 프로그래밍을 지원합니다.
*   **병렬 알고리즘 (Parallel Algorithms):** STL 알고리즘의 병렬 실행 버전을 제공하여 멀티코어 프로세서의 이점을 활용할 수 있게 합니다.

## C++20 (2020년 발표)
C++20은 C++17 이후의 주요 버전으로, 특히 "빅 4"로 불리는 핵심 기능(Concepts, Modules, Coroutines, Ranges)을 포함하여 언어와 라이브러리에 큰 변화를 가져왔습니다.
*   **컨셉트 (Concepts):** 템플릿 매개변수에 대한 제약 조건을 명시적으로 정의하여 컴파일 타임에 더 나은 오류 메시지를 제공하고 템플릿 메타프로그래밍을 단순화합니다.
*   **모듈 (Modules):** 헤더 파일의 한계를 극복하고 컴파일 시간을 단축하며, 매크로 오염을 줄여줍니다.
*   **코루틴 (Coroutines):** 비동기 프로그래밍을 위한 새로운 패러다임을 제공하여 비동기 코드를 동기 코드처럼 작성할 수 있게 합니다.
*   **레인지 (Ranges):** STL 알고리즘을 더욱 유연하고 조합 가능하게 만들어 데이터 시퀀스를 처리하는 새로운 방법을 제공합니다.
*   **삼방 비교 연산자 (`<=>`, "spaceship operator"):** `==`, `!=`, `<`, `<=`, `>`, `>=` 연산자를 한 번에 정의할 수 있게 하여 비교 연산자 오버로딩의 상용구 코드를 줄여줍니다.
*   **지정된 초기화 (Designated Initializers):** 구조체나 클래스의 멤버를 이름으로 초기화할 수 있게 합니다.
*   **`std::span`:** 연속된 메모리 영역을 참조하는 뷰(view)를 제공하여 배열이나 컨테이너의 일부를 안전하고 효율적으로 전달할 수 있게 합니다.

## C++23 (2023년 발표)
C++23은 C++20만큼 큰 변화는 아니지만, 언어와 라이브러리에 걸쳐 다양한 개선 사항과 새로운 기능을 도입했습니다.
*   **명시적 객체 매개변수 (`deducing this`):** 멤버 함수에서 `this` 포인터를 명시적으로 매개변수로 받을 수 있게 하여, `const` 및 `volatile` 한정자를 더 유연하게 처리하고 재귀 람다를 가능하게 합니다.
*   **`if consteval` 및 `if not consteval`:** 컴파일 타임 평가 컨텍스트를 명확하게 구분하여 코드를 작성할 수 있게 합니다.
*   **`std::flat_map`, `std::flat_set`:** `std::map` 및 `std::set`과 유사하지만, 내부적으로 연속된 메모리(예: `std::vector`)를 사용하여 캐시 효율성을 높인 컨테이너를 제공합니다.
*   **`std::generator`:** 코루틴을 기반으로 하는 제너레이터 함수를 위한 표준 라이브러리 지원을 제공합니다.
*   **문자열 포맷팅 개선:** `std::format`에 대한 개선 사항을 포함하여 문자열 포맷팅을 더욱 강력하고 유연하게 만듭니다.
*   **`std::expected`:** 오류 처리 메커니즘으로, 성공적인 값 또는 오류를 나타낼 수 있는 타입을 제공하여 예외 처리의 대안을 제시합니다.
*   **`std::mdspan`:** 다차원 배열을 위한 뷰를 제공하여 다차원 데이터에 대한 효율적인 접근을 가능하게 합니다.
*   **표준 라이브러리 모듈 (`std` 및 `std.compat`):** 표준 라이브러리를 모듈로 제공하여 컴파일 시간을 단축하고 모듈화된 프로그래밍을 지원합니다.