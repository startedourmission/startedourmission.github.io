---
date: 2025-07-01
tags:
  - C++
aliases:
---

# 컴파일과 링크

C++ 컴파일 및 링크 과정은 소스 코드가 실행 가능한 프로그램으로 변환되는 일련의 단계입니다. 주요 단계는 다음과 같습니다:

## 1. 전처리 (Preprocessing)

*   전처리기는 소스 코드(.cpp, .cxx 등)를 컴파일러가 처리하기 전에 준비합니다.
*   `#include` 지시문을 만나면 해당 헤더 파일(.h, .hpp)의 내용을 현재 파일에 삽입합니다.
*   `#define`과 같은 매크로를 실제 값이나 코드로 확장합니다.
*   `#ifdef`, `#ifndef`, `#if` 등의 조건부 컴파일 지시문을 처리하여 특정 코드 블록을 포함하거나 제외합니다.
*   결과물은 `.i` 또는 `.ii` 확장자를 가진 전처리된 소스 파일입니다.

## 2. 컴파일 (Compilation)

*   컴파일러는 전처리된 소스 파일(.i 또는 .ii)을 입력으로 받아 어셈블리 코드(.s 또는 .asm)로 변환합니다.
*   이 단계에서 문법 오류, 타입 불일치 등 C++ 언어 규칙 위반 여부를 검사합니다.
*   코드 최적화가 이 단계에서 수행될 수 있습니다.
*   결과물은 어셈블리 파일입니다.

## 3. 어셈블 (Assembly)

*   어셈블러는 어셈블리 코드(.s 또는 .asm)를 기계어 코드인 오브젝트 파일(.o 또는 .obj)로 변환합니다.
*   이 기계어 코드는 특정 CPU 아키텍처에 대한 이진 명령어 집합으로 구성됩니다.
*   아직 다른 파일이나 라이브러리의 함수 호출 주소 등은 결정되지 않은 상태입니다.
*   결과물은 오브젝트 파일(Object File)입니다.

## 4. 링크 (Linking)

*   링커는 하나 이상의 오브젝트 파일(.o 또는 .obj)과 필요한 라이브러리(정적 라이브러리 .a, .lib 또는 동적 라이브러리 .so, .dll)를 결합하여 최종 실행 가능한 프로그램(.exe, .out) 또는 또 다른 라이브러리를 생성합니다.
*   이 단계에서 오브젝트 파일들 간의 참조(예: 한 파일에서 다른 파일의 함수 호출)를 해결하고, 라이브러리에서 사용된 함수의 실제 주소를 연결합니다.
*   만약 참조를 해결할 수 없으면 "undefined reference"와 같은 링크 오류가 발생합니다.
*   결과물은 실행 가능한 파일 또는 공유 라이브러리입니다.

이 과정은 일반적으로 하나의 명령(예: `g++ main.cpp -o main`)으로 수행되지만, 내부적으로는 위에서 설명한 여러 단계가 순차적으로 진행됩니다.

---
### C++ 기본

- [[C++ - 개요 및 C 언어와의 차이점]]
- [[C++ - 기본 문법]]
- [[C++ - 컴파일과 링크]]
- [[C++ - IDE 및 개발 환경]]

### 객체 지향 프로그래밍 (OOP)

- [[C++ - 클래스와 객체]]
- [[C++ - 생성자 및 소멸자]]
- [[C++ - 캡슐화]]
- [[C++ - 상속]]
- [[C++ - 다형성]]
- [[C++ - 추상화]]

### 메모리 관리

- [[C++ - 동적 메모리 할당]]
- [[C++ - 스마트 포인터]]

### 고급 C++ 기능

- [[C++ - 포인터]]
- [[C++ - 참조]]
- [[C++ - 템플릿]]
- [[C++ - 예외 처리]]
- [[C++ - 표준 라이브러리 (STL)]]
- [[C++ - 파일 입출력]]
- [[C++ - 현대 C++]]

### 실무 C++

- [[C++ - 빌드 시스템]]
- [[C++ - 테스트 프레임워크]]
- [[C++ - 디버깅 기법]]
- [[C++ - 성능 최적화]]
- [[C++ - 디자인 패턴]]
- [[C++ - 실무에서 사용하는 C++의 변형]]
