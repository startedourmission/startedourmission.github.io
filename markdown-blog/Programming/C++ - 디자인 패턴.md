---
date: 2025-07-01
tags:
  - C++
aliases:
---

# 디자인 패턴

디자인 패턴은 소프트웨어 설계 및 개발 과정에서 자주 발생하는 공통적인 문제에 대한 재사용 가능한 해결책입니다. 이는 완성된 코드가 아니라, 특정 상황에 맞게 적용하고 확장할 수 있는 가이드라인 또는 템플릿으로, 유지보수 가능하고 유연하며 이해하기 쉬운 코드를 작성하는 데 도움을 줍니다.

디자인 패턴은 크게 세 가지 주요 유형으로 분류됩니다:

## 1. 생성 패턴 (Creational Design Patterns)

객체 생성 메커니즘을 다루는 패턴입니다. 상황에 적합한 방식으로 객체를 생성하여 생성 프로세스를 더 유연하고 덜 복잡하게 만드는 것을 목표로 합니다.

*   **싱글턴 패턴 (Singleton Pattern):** 클래스의 인스턴스가 오직 하나만 존재하도록 보장하고, 해당 인스턴스에 대한 전역적인 접근 지점을 제공합니다.
    ```cpp
    #include <iostream>

    class Singleton {
    private:
        static Singleton* instance;
        Singleton() { std::cout << "Singleton 인스턴스 생성" << std::endl; }

    public:
        static Singleton* getInstance() {
            if (instance == nullptr) {
                instance = new Singleton();
            }
            return instance;
        }

        void showMessage() {
            std::cout << "Hello from Singleton!" << std::endl;
        }

        // 복사 생성자와 할당 연산자 비활성화
        Singleton(const Singleton&) = delete;
        Singleton& operator=(const Singleton&) = delete;
    };

    Singleton* Singleton::instance = nullptr;

    int main() {
        Singleton* s1 = Singleton::getInstance();
        Singleton* s2 = Singleton::getInstance();

        s1->showMessage(); // 출력: Hello from Singleton!
        std::cout << "s1과 s2는 같은 인스턴스인가? " << (s1 == s2 ? "Yes" : "No") << std::endl; // 출력: Yes

        // delete s1; // 싱글턴은 일반적으로 프로그램 종료 시 자동으로 해제되거나, 명시적인 해제 함수를 제공
        return 0;
    }
    ```

*   **팩토리 메서드 패턴 (Factory Method Pattern):** 객체 생성을 위한 인터페이스를 정의하지만, 실제 인스턴스 생성은 서브클래스에서 결정하도록 합니다.
*   **추상 팩토리 패턴 (Abstract Factory Pattern):** 관련 있거나 의존적인 객체들의 패밀리를 구체적인 클래스를 지정하지 않고 생성하기 위한 인터페이스를 제공합니다.
*   **빌더 패턴 (Builder Pattern):** 복잡한 객체의 생성 과정을 표현 방식과 분리하여, 동일한 생성 과정을 통해 다양한 표현을 만들 수 있도록 합니다.
*   **프로토타입 패턴 (Prototype Pattern):** 기존 객체를 복사하여 새로운 객체를 생성함으로써, 코드에서 객체의 클래스에 의존하지 않고 객체를 복사할 수 있도록 합니다.

## 2. 구조 패턴 (Structural Design Patterns)

클래스와 객체가 더 큰 구조를 형성하도록 구성하는 방법을 다루며, 시스템 설계를 더 유연하고 확장 가능하며 효율적으로 만듭니다.

*   **어댑터 패턴 (Adapter Pattern):** 호환되지 않는 인터페이스를 가진 클래스들이 함께 작동할 수 있도록 중간에서 변환 역할을 합니다.
*   **브릿지 패턴 (Bridge Pattern):** 객체의 추상화와 구현을 분리하여, 둘이 독립적으로 변경될 수 있도록 합니다.
*   **컴포지트 패턴 (Composite Pattern):** 객체들을 트리 구조로 구성하여 부분-전체 계층을 표현하고, 클라이언트가 개별 객체와 객체들의 조합을 동일하게 다룰 수 있도록 합니다.
*   **데코레이터 패턴 (Decorator Pattern):** 객체에 새로운 행동이나 책임을 동적으로 추가합니다.
*   **퍼사드 패턴 (Facade Pattern):** 복잡한 서브시스템에 대한 단순화된 인터페이스를 제공합니다.
*   **프록시 패턴 (Proxy Pattern):** 다른 객체에 대한 대리자 또는 자리 표시자를 제공하여 해당 객체에 대한 접근을 제어합니다.
*   **플라이웨이트 패턴 (Flyweight Pattern):** 여러 객체 간에 공통된 상태의 일부를 공유하여 생성되는 객체의 수를 줄이고 성능 및 메모리 사용량을 개선합니다.

## 3. 행위 패턴 (Behavioral Design Patterns)

시스템 내의 다른 객체들이 어떻게 통신하고 상호작용하는지에 초점을 맞추어, 객체 간의 통신과 조정을 개선하고 시스템 설계를 더 유연하고 확장 가능하게 만듭니다.

*   **책임 연쇄 패턴 (Chain of Responsibility Pattern):** 요청을 처리할 수 있는 여러 객체에게 요청을 전달하여, 요청을 보내는 객체와 받는 객체 간의 결합도를 낮춥니다.
*   **커맨드 패턴 (Command Pattern):** 요청을 객체로 캡슐화하여, 클라이언트를 다양한 요청으로 매개변수화하고, 요청을 큐에 넣거나 로깅하며, 실행 취소 가능한 작업을 지원할 수 있도록 합니다.
*   **이터레이터 패턴 (Iterator Pattern):** 집합 객체의 내부 표현을 노출하지 않고도 그 집합체 안에 있는 모든 항목에 순차적으로 접근할 수 있는 방법을 제공합니다.
*   **메디에이터 패턴 (Mediator Pattern):** 객체 간의 직접적인 통신을 제한하고 중재자 객체를 통해서만 협력하도록 강제하여 객체 간의 혼란스러운 의존성을 줄입니다.
*   **옵저버 패턴 (Observer Pattern):** 한 객체의 상태가 변경될 때, 해당 객체에 의존하는 모든 객체들에게 자동으로 알림을 보내고 업데이트되도록 하는 일대다 의존성을 정의합니다.
*   **상태 패턴 (State Pattern):** 객체의 내부 상태가 변경될 때 객체의 행동을 변경할 수 있도록 하여, 마치 객체가 클래스를 변경한 것처럼 보이게 합니다.
*   **전략 패턴 (Strategy Pattern):** 알고리즘 군을 정의하고, 각 알고리즘을 하나의 클래스로 캡슐화한 다음, 필요할 때 서로 교환하여 사용할 수 있도록 합니다. 이를 통해 알고리즘이 이를 사용하는 클라이언트와 독립적으로 변경될 수 있습니다.
*   **템플릿 메서드 패턴 (Template Method Pattern):** 알고리즘의 골격은 슈퍼클래스에 정의하고, 알고리즘의 특정 단계는 서브클래스에서 재정의할 수 있도록 합니다. 이를 통해 알고리즘의 구조를 변경하지 않고도 특정 단계의 구현을 바꿀 수 있습니다.
*   **비지터 패턴 (Visitor Pattern):** 객체 구조에서 처리 기능을 분리하여 별도의 클래스를 만들어 놓고, 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 합니다.

디자인 패턴을 이해하고 적용하는 것은 더 나은, 더 견고하고, 더 유지보수 가능한 C++ 프로그램을 작성하는 데 크게 도움이 됩니다.

---
### C++ 기본

- [[C++ - 개요 및 C 언어와의 차이점]]
- [[C++ - 기본 문법]]
- [[C++ - 컴파일과 링크]]
- [[C++ - IDE 및 개발 환경]]

### 객체 지향 프로그래밍 (OOP)

- [[C++ - 클래스와 객체]]
- [[C++ - 생성자 및 소멸자]]
- [[C++ - 캡슐화]]
- [[C++ - 상속]]
- [[C++ - 다형성]]
- [[C++ - 추상화]]

### 메모리 관리

- [[C++ - 동적 메모리 할당]]
- [[C++ - 스마트 포인터]]

### 고급 C++ 기능

- [[C++ - 포인터]]
- [[C++ - 참조]]
- [[C++ - 템플릿]]
- [[C++ - 예외 처리]]
- [[C++ - 표준 라이브러리 (STL)]]
- [[C++ - 파일 입출력]]
- [[C++ - 현대 C++]]

### 실무 C++

- [[C++ - 빌드 시스템]]
- [[C++ - 테스트 프레임워크]]
- [[C++ - 디버깅 기법]]
- [[C++ - 성능 최적화]]
- [[C++ - 디자인 패턴]]
- [[C++ - 실무에서 사용하는 C++의 변형]]
